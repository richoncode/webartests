<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The 2D Gaussian: Evaluation &amp; Bounds</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: #0d0d0d;
    color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 15px;
    line-height: 1.7;
  }

  .back-link {
    position: fixed;
    top: 20px;
    left: 24px;
    color: #555;
    text-decoration: none;
    font-size: 14px;
    z-index: 100;
  }
  .back-link:hover { color: #888; }

  .page {
    max-width: 720px;
    margin: 0 auto;
    padding: 60px 24px;
  }

  .page-header {
    margin-bottom: 56px;
  }

  h1 {
    font-size: 32px;
    font-weight: 800;
    margin-bottom: 12px;
  }

  .subtitle {
    color: #999;
    font-size: 15px;
    line-height: 1.7;
    max-width: 600px;
  }

  .section {
    margin-bottom: 64px;
  }

  .section-title {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 12px;
  }

  p {
    color: #999;
    line-height: 1.7;
    margin-bottom: 12px;
  }

  pre {
    background: #0a0a0a;
    border: 1px solid #222;
    color: #a8e6cf;
    padding: 16px;
    border-radius: 8px;
    font-size: 13px;
    line-height: 1.6;
    overflow-x: auto;
    margin-bottom: 20px;
    white-space: pre;
  }

  canvas {
    display: block;
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 8px;
    width: 100%;
    max-width: 640px;
    margin: 20px auto;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    margin-bottom: 20px;
    align-items: center;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .control-group label {
    font-size: 12px;
    color: #555;
  }

  .control-group input[type=range] {
    width: 160px;
    accent-color: #5b9bd5;
  }

  .control-group .value {
    font-size: 12px;
    color: #888;
    font-variant-numeric: tabular-nums;
  }

  button {
    background: #1a1a1a;
    border: 1px solid #333;
    color: #ccc;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 13px;
    cursor: pointer;
  }
  button:hover { background: #222; border-color: #555; color: #fff; }

  .highlight-blue  { color: #5b9bd5; }
  .highlight-amber { color: #e8a838; }
  .highlight-green { color: #50dc96; }
  .highlight-red   { color: #dc5050; }

  /* Extra page-specific styles */
  .matrix-display {
    display: flex;
    gap: 32px;
    flex-wrap: wrap;
    margin-bottom: 20px;
  }

  .matrix-box {
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 13px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    min-width: 200px;
  }

  .matrix-box .matrix-label {
    font-size: 11px;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }

  .matrix-row {
    display: flex;
    gap: 12px;
    line-height: 1.8;
  }

  .matrix-val {
    display: inline-block;
    width: 70px;
    text-align: right;
    color: #a8e6cf;
    font-variant-numeric: tabular-nums;
  }

  .gallery-canvas {
    display: block;
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 8px;
    width: 100%;
    max-width: 640px;
    margin: 20px auto;
  }

  .gallery-labels {
    display: flex;
    justify-content: space-around;
    max-width: 640px;
    margin: -12px auto 20px auto;
    flex-wrap: wrap;
    gap: 4px;
  }

  .gallery-label {
    font-size: 11px;
    color: #555;
    text-align: center;
    width: 100px;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  /* Buffer loader table */
  .buffer-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    margin-bottom: 20px;
  }

  .buffer-table th {
    text-align: left;
    color: #555;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 8px 10px;
    border-bottom: 1px solid #222;
    font-weight: 600;
  }

  .buffer-table td {
    padding: 6px 10px;
    border-bottom: 1px solid #1a1a1a;
    vertical-align: middle;
    color: #999;
  }

  .buffer-table tr:last-child td {
    border-bottom: none;
  }

  .buffer-table td:nth-child(1) {
    color: #888;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 12px;
    width: 120px;
  }

  .buffer-table td:nth-child(2) {
    width: 180px;
  }

  .buffer-table input[type=range] {
    width: 140px;
    accent-color: #5b9bd5;
    vertical-align: middle;
  }

  .buf-raw, .buf-norm, .buf-final {
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 12px;
    font-variant-numeric: tabular-nums;
    display: inline-block;
    width: 58px;
    text-align: right;
  }
  .buf-raw   { color: #dc5050; }
  .buf-norm  { color: #e8a838; }
  .buf-final { color: #50dc96; }

  .buf-layout {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  .buf-table-wrap {
    flex: 1;
    min-width: 340px;
  }

  .buf-preview-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .buf-preview-canvas {
    display: block;
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 8px;
    width: 200px;
    height: 200px;
  }

  .buf-preview-label {
    font-size: 11px;
    color: #555;
    text-align: center;
  }

  .eigentext {
    background: #0a0a0a;
    border: 1px solid #222;
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 12px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    color: #888;
    margin-bottom: 16px;
    font-variant-numeric: tabular-nums;
  }
</style>
</head>
<body>

<a class="back-link" href="../">← Back</a>

<div class="page">

  <!-- PAGE HEADER -->
  <div class="page-header">
    <h1>The 2D Gaussian: Evaluation &amp; Bounds</h1>
    <p class="subtitle">How a 2D Gaussian blob is parameterised by a covariance matrix, how it's evaluated at a UV coordinate, and how its oriented bounding box is extracted via eigendecomposition.</p>
  </div>

  <!-- STRUCT CODE -->
  <div class="section">
    <div class="section-title">The <span class="highlight-green">Gaussian2D</span> Struct</div>
    <p>In the Slang shader, each Gaussian is a struct holding its center, covariance matrix, color, and opacity. The two key methods are <code class="highlight-green">eval()</code> — which evaluates the Gaussian's contribution at a UV coordinate — and <code class="highlight-green">bounds()</code> — which computes an oriented bounding box for culling.</p>
<pre>struct Gaussian2D : IDifferentiable
{
    float2 center;
    float2x2 sigma;   // covariance matrix
    float3 color;
    float opacity;

    [Differentiable]
    float4 eval(float2 uv)
    {
        float2x2 invCov = inverse(sigma);
        float2 diff = uv - center;
        float power = -0.5f * (
            diff.x * diff.x * invCov[0][0] +
            diff.y * diff.y * invCov[1][1] +
            diff.x * diff.y * invCov[0][1] +
            diff.y * diff.x * invCov[1][0]);
        float weight = min(.99f, opacity * exp(power));
        return float4(color, weight);
    }

    OBB bounds()
    {
        float a = sigma[0][0], b = sigma[0][1];
        float c = sigma[1][0], d = sigma[1][1];
        float n_stddev = 4.f;

        if (abs(b) < 1e-6 || abs(c) < 1e-6) {
            float2x2 eigenvectors = float2x2(float2(1,0), float2(0,1));
            float2 scale = float2(sqrt(a), sqrt(d));
            return OBB(center, eigenvectors, scale * n_stddev);
        } else {
            float trace = a + d;
            float det = a * d - b * c;
            float lambda1 = 0.5 * (trace + sqrt(trace*trace - 4*det));
            float lambda2 = 0.5 * (trace - sqrt(trace*trace - 4*det));
            float2x2 eigenvectors;
            eigenvectors[0] = normalize(float2(lambda1 - d, c));
            eigenvectors[1] = normalize(float2(b, lambda2 - a));
            float2 scale = float2(sqrt(lambda1), sqrt(lambda2));
            return OBB(center, eigenvectors, scale * n_stddev);
        }
    }
}</pre>
  </div>

  <!-- SECTION 1 — THE MULTIVARIATE GAUSSIAN -->
  <div class="section">
    <div class="section-title">1. The Multivariate Gaussian</div>
    <p>A 2D Gaussian is fully defined by a center (mean) <span class="highlight-blue">μ</span> and a covariance matrix <span class="highlight-blue">Σ</span>. The unnormalized value at point <span class="highlight-blue">p</span> is:</p>
<pre>f(p) = exp(-0.5 * (p - μ)ᵀ Σ⁻¹ (p - μ))</pre>
    <p>The covariance matrix <span class="highlight-blue">Σ</span> is a 2×2 symmetric matrix:</p>
<pre>Σ = [[σ_xx,  σ_xy],
     [σ_yx,  σ_yy]]   where σ_xy = σ_yx</pre>
    <p>The diagonal entries <span class="highlight-amber">σ_xx</span> and <span class="highlight-amber">σ_yy</span> control how spread out the Gaussian is along the x and y axes respectively. The off-diagonal entry <span class="highlight-amber">σ_xy</span> controls the tilt — a positive value tilts the blob toward 45°, a negative value toward −45°. When <span class="highlight-amber">σ_xy = 0</span>, the Gaussian is axis-aligned.</p>
    <p>The <code class="highlight-green">power</code> computation in <code>eval()</code> expands the matrix-vector quadratic form manually into scalar operations:</p>
<pre>(p-μ)ᵀ Σ⁻¹ (p-μ) = diff.x² * invCov[0][0]
                   + diff.y² * invCov[1][1]
                   + diff.x * diff.y * invCov[0][1]
                   + diff.y * diff.x * invCov[1][0]</pre>
    <p>Because <span class="highlight-blue">Σ</span> is symmetric, its inverse is also symmetric: <code>invCov[0][1] = invCov[1][0]</code>. The last two terms therefore double up the cross contribution — this is equivalent to <code>2 * diff.x * diff.y * invCov[0][1]</code>.</p>

    <p>The weight returned by <code>eval()</code> is <code>min(0.99, opacity * exp(power))</code> — clamped below 1 to avoid fully occluding pixels in a single splat.</p>

    <!-- Demo 1 controls -->
    <div class="controls" id="demo1-controls">
      <div class="control-group">
        <label>Center X</label>
        <input type="range" id="d1-cx" min="0.1" max="0.9" step="0.01" value="0.5">
        <span class="value" id="d1-cx-val">0.50</span>
      </div>
      <div class="control-group">
        <label>Center Y</label>
        <input type="range" id="d1-cy" min="0.1" max="0.9" step="0.01" value="0.5">
        <span class="value" id="d1-cy-val">0.50</span>
      </div>
      <div class="control-group">
        <label>sigma[0][0] (x-variance)</label>
        <input type="range" id="d1-sxx" min="0.001" max="0.05" step="0.001" value="0.015">
        <span class="value" id="d1-sxx-val">0.0150</span>
      </div>
      <div class="control-group">
        <label>sigma[1][1] (y-variance)</label>
        <input type="range" id="d1-syy" min="0.001" max="0.05" step="0.001" value="0.008">
        <span class="value" id="d1-syy-val">0.0080</span>
      </div>
      <div class="control-group">
        <label>sigma[0][1] (correlation)</label>
        <input type="range" id="d1-aniso" min="-0.9" max="0.9" step="0.01" value="0.3">
        <span class="value" id="d1-aniso-val">0.30</span>
      </div>
      <div class="control-group">
        <label>Color</label>
        <input type="color" id="d1-color" value="#4a9eff" style="width:48px;height:32px;border:1px solid #333;border-radius:4px;background:#1a1a1a;cursor:pointer;padding:2px;">
      </div>
      <div class="control-group">
        <label>Opacity</label>
        <input type="range" id="d1-opacity" min="0.1" max="1.0" step="0.01" value="0.9">
        <span class="value" id="d1-opacity-val">0.90</span>
      </div>
    </div>

    <canvas id="canvas-demo1" width="640" height="400"></canvas>

    <!-- Matrix display -->
    <div class="matrix-display">
      <div class="matrix-box">
        <div class="matrix-label">Covariance &Sigma;</div>
        <div class="matrix-row">
          <span class="matrix-val" id="m-sxx">0.01500</span>
          <span class="matrix-val" id="m-sxy">0.00000</span>
        </div>
        <div class="matrix-row">
          <span class="matrix-val" id="m-syx">0.00000</span>
          <span class="matrix-val" id="m-syy">0.00800</span>
        </div>
      </div>
      <div class="matrix-box">
        <div class="matrix-label">Inverse Covariance &Sigma;<sup>-1</sup></div>
        <div class="matrix-row">
          <span class="matrix-val" id="m-isxx">0.00000</span>
          <span class="matrix-val" id="m-isxy">0.00000</span>
        </div>
        <div class="matrix-row">
          <span class="matrix-val" id="m-isyx">0.00000</span>
          <span class="matrix-val" id="m-isyy">0.00000</span>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION 2 — COVARIANCE SHAPES -->
  <div class="section">
    <div class="section-title">2. Covariance Matrix Shapes</div>
    <p>Different covariance matrices produce very different Gaussian shapes. A valid covariance matrix must be <strong style="color:#ccc;">positive semi-definite</strong> — all eigenvalues must be ≥ 0. This ensures the Gaussian's "spread" is always real-valued and non-negative in every direction.</p>
    <p>The five archetypes below cover the main shapes you'll encounter. Notice how the off-diagonal entry rotates the principal axes away from the x/y grid:</p>

    <canvas id="canvas-gallery" width="640" height="220"></canvas>
    <div class="gallery-labels">
      <div class="gallery-label">Circular<br>[[s,0],[0,s]]</div>
      <div class="gallery-label">Elongated X<br>[[big,0],[0,small]]</div>
      <div class="gallery-label">Elongated Y<br>[[small,0],[0,big]]</div>
      <div class="gallery-label">Tilted +45°<br>[[s,0.8s],[0.8s,s]]</div>
      <div class="gallery-label">Tilted −45°<br>[[s,-0.8s],[-0.8s,s]]</div>
    </div>
  </div>

  <!-- SECTION 3 — THE INVERSE COVARIANCE -->
  <div class="section">
    <div class="section-title">3. The Inverse Covariance (Precision Matrix)</div>
    <p>The <code>eval()</code> method calls <code>inverse(sigma)</code> to get the precision matrix before computing the quadratic form. For a 2×2 matrix the formula is:</p>
<pre>inverse([[a, b], [c, d]]) = (1 / (ad - bc)) * [[d, -b], [-c, a]]</pre>
    <p>The inverse covariance (also called the <span class="highlight-amber">precision matrix</span>) determines how "tight" or "loose" the Gaussian is:</p>
    <p>A <span class="highlight-green">large variance</span> (large diagonal in Σ) gives <span class="highlight-green">small precision values</span> — the exponent decays slowly, giving a broad, diffuse blob. A <span class="highlight-red">small variance</span> gives <span class="highlight-red">large precision values</span> — the exponent decays quickly, giving a sharp, narrow spike.</p>
    <p>The matrix display below the Demo 1 canvas updates in real time as you move the sliders, letting you see exactly how Σ⁻¹ changes with the parameters.</p>
<pre>[Differentiable]
float2x2 inverse(float2x2 mat) {
    float det = determinant(mat);
    return float2x2(
        mat[1][1] / det, -mat[0][1] / det,
       -mat[1][0] / det,  mat[0][0] / det);
}</pre>
    <p>Because <code>inverse()</code> is marked <code>[Differentiable]</code>, the autograd system can backpropagate gradients through it — including through the determinant division. This is what makes it possible to train the covariance parameters directly via gradient descent on a rendering loss.</p>
  </div>

  <!-- SECTION 4 — EIGENDECOMPOSITION & OBB -->
  <div class="section">
    <div class="section-title">4. The <code>bounds()</code> Method: Eigendecomposition</div>
    <p>During rendering, Gaussians are processed tile by tile. Before computing any pixels, we need to know <em style="color:#ccc;">which tiles a Gaussian can possibly affect</em>. A Gaussian with very small weight at some pixel contributes nothing — so we can skip it entirely. The <code>bounds()</code> method computes an <span class="highlight-green">Oriented Bounding Box (OBB)</span> that encloses the region where the Gaussian's weight exceeds a meaningful threshold.</p>

    <p>The key insight: the Gaussian's shape is exactly described by the eigenvectors and eigenvalues of <span class="highlight-blue">Σ</span>. The eigenvectors give the <em style="color:#ccc;">principal axes</em> (directions of maximum/minimum spread), and the square roots of the eigenvalues give the <em style="color:#ccc;">standard deviations</em> along those axes.</p>

    <p><strong style="color:#ccc;">Eigenvalues of Σ:</strong></p>
<pre>trace = σ_xx + σ_yy
det   = σ_xx * σ_yy - σ_xy²

λ₁ = (trace + √(trace² - 4·det)) / 2
λ₂ = (trace - √(trace² - 4·det)) / 2</pre>

    <p><strong style="color:#ccc;">Eigenvectors</strong> give the principal axes (directions of maximum/minimum spread):</p>
<pre>v₁ = normalize((λ₁ - σ_yy, σ_yx))
v₂ = normalize((σ_xy, λ₂ - σ_xx))</pre>

    <p><strong style="color:#ccc;">OBB scale</strong> = <code>n_stddev * (√λ₁, √λ₂)</code> where <code class="highlight-amber">n_stddev = 4</code> — the box extends 4 standard deviations in each principal direction. At 4σ, <code>exp(-0.5 * 16) ≈ 0.00034</code>, meaning the Gaussian has decayed to well under 0.1% of its peak value. This captures &gt;99.99% of the Gaussian's mass while keeping tiles tiny.</p>

    <p><strong style="color:#ccc;">The diagonal shortcut:</strong> when <code>|σ_xy| &lt; 1e-6</code>, the covariance is already diagonal — the eigenvectors are exactly the x and y unit vectors, so the OBB aligns with the canvas axes and no eigendecomposition is needed.</p>

    <!-- Demo 3 controls -->
    <div class="controls" id="demo3-controls">
      <div class="control-group">
        <label>Center X</label>
        <input type="range" id="d3-cx" min="0.1" max="0.9" step="0.01" value="0.5">
        <span class="value" id="d3-cx-val">0.50</span>
      </div>
      <div class="control-group">
        <label>Center Y</label>
        <input type="range" id="d3-cy" min="0.1" max="0.9" step="0.01" value="0.5">
        <span class="value" id="d3-cy-val">0.50</span>
      </div>
      <div class="control-group">
        <label>sigma[0][0] (x-variance)</label>
        <input type="range" id="d3-sxx" min="0.001" max="0.05" step="0.001" value="0.015">
        <span class="value" id="d3-sxx-val">0.0150</span>
      </div>
      <div class="control-group">
        <label>sigma[1][1] (y-variance)</label>
        <input type="range" id="d3-syy" min="0.001" max="0.05" step="0.001" value="0.008">
        <span class="value" id="d3-syy-val">0.0080</span>
      </div>
      <div class="control-group">
        <label>sigma[0][1] (correlation)</label>
        <input type="range" id="d3-aniso" min="-0.9" max="0.9" step="0.01" value="0.3">
        <span class="value" id="d3-aniso-val">0.30</span>
      </div>
      <div class="control-group">
        <label>Color</label>
        <input type="color" id="d3-color" value="#4a9eff" style="width:48px;height:32px;border:1px solid #333;border-radius:4px;background:#1a1a1a;cursor:pointer;padding:2px;">
      </div>
      <div class="control-group">
        <label>Opacity</label>
        <input type="range" id="d3-opacity" min="0.1" max="1.0" step="0.01" value="0.9">
        <span class="value" id="d3-opacity-val">0.90</span>
      </div>
    </div>

    <canvas id="canvas-demo3" width="640" height="400"></canvas>

    <div class="eigentext" id="d3-eigentext">
      λ₁ = 0.000, λ₂ = 0.000 &nbsp;|&nbsp; v₁ = (0.000, 0.000), v₂ = (0.000, 0.000) &nbsp;|&nbsp; path: diagonal shortcut
    </div>
  </div>

  <!-- SECTION 5 — LOADING PARAMETERS -->
  <div class="section">
    <div class="section-title">5. Loading Parameters with <code>load()</code></div>
    <p>During optimisation, Gaussian parameters are stored as raw unconstrained floats in a differentiable buffer. The <code>load()</code> function maps these raw values into the valid parameter ranges using <span class="highlight-amber">smoothStep</span> — a smooth Hermite interpolation that approaches 0 at x → −∞ and 1 at x → +∞, with zero derivative at both ends. This prevents the optimiser from getting gradient signals that push parameters out of valid ranges.</p>

    <p>The mapping pipeline for each parameter:</p>
    <ul style="color:#999; padding-left: 20px; margin-bottom: 12px; line-height: 2;">
      <li><span class="highlight-blue">center.x / center.y</span> — raw float → smoothStep → [0, 1] UV space</li>
      <li><span class="highlight-blue">sigma[0][0] / sigma[1][1]</span> — scaled raw float → smoothStep → small padding (0.005) added to avoid singularities in the matrix inverse</li>
      <li><span class="highlight-blue">anisotropy</span> — raw float → smoothStep → mapped to (−0.825, +0.825), then <code>sigma[0][1] = sigma[1][0] = sqrt(sxx * syy) * aniso</code> ensures the matrix stays positive semi-definite</li>
      <li><span class="highlight-blue">color.r / g / b</span> — raw floats → smoothStep → [0, 1] per channel</li>
      <li><span class="highlight-blue">opacity</span> — raw float → smoothStep → [0, 1]</li>
    </ul>

<pre>Gaussian2D load(DiffTensorView buf, int idx) {
    Gaussian2D g;
    // Center: smoothstep maps any real -> [0,1]
    g.center.x = smoothstep(buf[idx * 9 + 0]);
    g.center.y = smoothstep(buf[idx * 9 + 1]);

    // Diagonals: scale raw value, smoothstep, add padding
    g.sigma[0][0] = smoothstep(buf[idx * 9 + 2] * 0.1) * 0.05 + 0.005;
    g.sigma[1][1] = smoothstep(buf[idx * 9 + 3] * 0.1) * 0.05 + 0.005;

    // Anisotropy: smoothstep -> [-0.825, +0.825]
    float aniso = (smoothstep(buf[idx * 9 + 4]) - 0.5) * 1.65;
    g.sigma[0][1] = g.sigma[1][0] =
        sqrt(g.sigma[0][0] * g.sigma[1][1]) * aniso;

    // Color channels
    g.color.r = smoothstep(buf[idx * 9 + 5]);
    g.color.g = smoothstep(buf[idx * 9 + 6]);
    g.color.b = smoothstep(buf[idx * 9 + 7]);

    // Opacity
    g.opacity  = smoothstep(buf[idx * 9 + 8]);
    return g;
}</pre>

    <p>The interactive visualiser below lets you explore how raw buffer values flow through the smoothStep mapping into final Gaussian parameters, and see the resulting Gaussian in real time.</p>

    <div class="buf-layout">
      <div class="buf-table-wrap">
        <table class="buffer-table">
          <thead>
            <tr>
              <th>Field</th>
              <th>Raw slider (−2 → 2)</th>
              <th style="color:#dc5050">Raw</th>
              <th style="color:#e8a838">Norm</th>
              <th style="color:#50dc96">Final</th>
            </tr>
          </thead>
          <tbody id="buf-tbody">
          </tbody>
        </table>
      </div>
      <div class="buf-preview-wrap">
        <canvas id="canvas-buf" class="buf-preview-canvas" width="200" height="200"></canvas>
        <div class="buf-preview-label">Live Gaussian preview</div>
      </div>
    </div>
  </div>

</div><!-- end .page -->

<script>
// ─────────────────────────────────────────────
//  MATH UTILITIES
// ─────────────────────────────────────────────

function invertMatrix2x2(a, b, c, d) {
  const det = a * d - b * c;
  if (Math.abs(det) < 1e-12) return { ia: 0, ib: 0, ic: 0, id: 0 };
  return {
    ia:  d / det,
    ib: -b / det,
    ic: -c / det,
    id:  a / det
  };
}

function evalGaussian(ux, uy, cx, cy, sxx, sxy, syy, opacity) {
  const { ia, ib, ic, id } = invertMatrix2x2(sxx, sxy, sxy, syy);
  const dx = ux - cx;
  const dy = uy - cy;
  const power = -0.5 * (
    dx * dx * ia +
    dy * dy * id +
    dx * dy * ib +
    dy * dx * ic
  );
  return Math.min(0.99, opacity * Math.exp(power));
}

function eigendecompose(a, b, c, d) {
  const trace = a + d;
  const det = a * d - b * c;
  const disc = Math.max(0, trace * trace - 4 * det);
  const sqrtDisc = Math.sqrt(disc);
  const lambda1 = 0.5 * (trace + sqrtDisc);
  const lambda2 = 0.5 * (trace - sqrtDisc);

  let v1x, v1y, v2x, v2y;
  if (Math.abs(b) < 1e-6 || Math.abs(c) < 1e-6) {
    v1x = 1; v1y = 0;
    v2x = 0; v2y = 1;
  } else {
    const n1 = Math.sqrt((lambda1 - d) * (lambda1 - d) + c * c);
    v1x = n1 > 1e-9 ? (lambda1 - d) / n1 : 1;
    v1y = n1 > 1e-9 ? c / n1 : 0;
    const n2 = Math.sqrt(b * b + (lambda2 - a) * (lambda2 - a));
    v2x = n2 > 1e-9 ? b / n2 : 0;
    v2y = n2 > 1e-9 ? (lambda2 - a) / n2 : 1;
  }
  return { lambda1, lambda2, v1x, v1y, v2x, v2y };
}

// ─────────────────────────────────────────────
//  HEATMAP RENDERER (ImageData)
// ─────────────────────────────────────────────

function renderHeatmap(canvas, cx, cy, sxx, sxy, syy, r, g, b, opacity) {
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth  || canvas.width;
  const cssH = canvas.clientHeight || canvas.height;
  const pw = Math.round(cssW * dpr);
  const ph = Math.round(cssH * dpr);
  if (canvas.width !== pw || canvas.height !== ph) {
    canvas.width  = pw;
    canvas.height = ph;
  }
  const ctx = canvas.getContext('2d');
  const imgData = ctx.createImageData(pw, ph);
  const data = imgData.data;

  for (let py = 0; py < ph; py++) {
    for (let px = 0; px < pw; px++) {
      const ux = px / (pw - 1);
      const uy = py / (ph - 1);
      const w = evalGaussian(ux, uy, cx, cy, sxx, sxy, syy, opacity);
      const idx = (py * pw + px) * 4;
      data[idx + 0] = Math.round(r * w * 255);
      data[idx + 1] = Math.round(g * w * 255);
      data[idx + 2] = Math.round(b * w * 255);
      data[idx + 3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  return ctx;
}

// ─────────────────────────────────────────────
//  ISO-CONTOUR OVERLAY
// ─────────────────────────────────────────────

function drawIsoContours(canvas, cx, cy, sxx, sxy, syy, opacity) {
  const dpr = window.devicePixelRatio || 1;
  const pw = canvas.width;
  const ph = canvas.height;
  const ctx = canvas.getContext('2d');
  const thresholds = [0.6, 0.3, 0.1];
  const epsilon = 0.025;

  ctx.save();
  ctx.globalAlpha = 0.6;
  for (const thresh of thresholds) {
    ctx.beginPath();
    for (let py = 0; py < ph; py++) {
      for (let px = 0; px < pw; px++) {
        const ux = px / (pw - 1);
        const uy = py / (ph - 1);
        const w = evalGaussian(ux, uy, cx, cy, sxx, sxy, syy, opacity);
        if (Math.abs(w - thresh) < epsilon) {
          ctx.rect(px, py, 1, 1);
        }
      }
    }
    ctx.fillStyle = '#ffffff';
    ctx.fill();
  }
  ctx.restore();
}

// ─────────────────────────────────────────────
//  CENTER CROSSHAIR
// ─────────────────────────────────────────────

function drawCrosshair(canvas, cx, cy, color) {
  const pw = canvas.width;
  const ph = canvas.height;
  const ctx = canvas.getContext('2d');
  const px = cx * (pw - 1);
  const py = cy * (ph - 1);
  const s = 8;
  ctx.save();
  ctx.strokeStyle = color || '#fff';
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.moveTo(px - s, py);
  ctx.lineTo(px + s, py);
  ctx.moveTo(px, py - s);
  ctx.lineTo(px, py + s);
  ctx.stroke();
  ctx.restore();
}

// ─────────────────────────────────────────────
//  PRINCIPAL AXIS ARROWS
// ─────────────────────────────────────────────

function drawArrow(ctx, x0, y0, x1, y1, color, width) {
  const dx = x1 - x0;
  const dy = y1 - y0;
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len < 1) return;
  const ux = dx / len;
  const uy = dy / len;
  const hw = 6;
  const hl = 10;
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = width || 1.5;
  ctx.globalAlpha = 0.85;
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1 - ux * hl, y1 - uy * hl);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x1 - ux * hl - uy * hw, y1 - uy * hl + ux * hw);
  ctx.lineTo(x1 - ux * hl + uy * hw, y1 - uy * hl - ux * hw);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPrincipalAxes(canvas, cx, cy, sxx, sxy, syy) {
  const pw = canvas.width;
  const ph = canvas.height;
  const ctx = canvas.getContext('2d');
  const { lambda1, lambda2, v1x, v1y, v2x, v2y } = eigendecompose(sxx, sxy, sxy, syy);
  const px = cx * (pw - 1);
  const py = cy * (ph - 1);
  const scale = Math.min(pw, ph);
  const len1 = Math.sqrt(Math.max(0, lambda1)) * scale;
  const len2 = Math.sqrt(Math.max(0, lambda2)) * scale;
  drawArrow(ctx, px, py, px + v1x * len1, py + v1y * len1, '#5b9bd5', 1.5);
  drawArrow(ctx, px, py, px - v1x * len1, py - v1y * len1, '#5b9bd5', 1.5);
  drawArrow(ctx, px, py, px + v2x * len2, py + v2y * len2, '#e8a838', 1.5);
  drawArrow(ctx, px, py, px - v2x * len2, py - v2y * len2, '#e8a838', 1.5);
}

// ─────────────────────────────────────────────
//  OBB OVERLAY
// ─────────────────────────────────────────────

function drawOBB(canvas, cx, cy, sxx, sxy, syy) {
  const pw = canvas.width;
  const ph = canvas.height;
  const ctx = canvas.getContext('2d');
  const { lambda1, lambda2, v1x, v1y, v2x, v2y } = eigendecompose(sxx, sxy, sxy, syy);

  const n_stddev = 4;
  const scale1 = Math.sqrt(Math.max(0, lambda1)) * n_stddev;
  const scale2 = Math.sqrt(Math.max(0, lambda2)) * n_stddev;

  const scaleX = pw - 1;
  const scaleY = ph - 1;
  const pcx = cx * scaleX;
  const pcy = cy * scaleY;

  // OBB corners in UV space, then to pixel space
  const corners = [
    [ cx + v1x * scale1 + v2x * scale2,  cy + v1y * scale1 + v2y * scale2 ],
    [ cx + v1x * scale1 - v2x * scale2,  cy + v1y * scale1 - v2y * scale2 ],
    [ cx - v1x * scale1 - v2x * scale2,  cy - v1y * scale1 - v2y * scale2 ],
    [ cx - v1x * scale1 + v2x * scale2,  cy - v1y * scale1 + v2y * scale2 ],
  ];

  ctx.save();
  ctx.strokeStyle = '#50dc96';
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.8;
  ctx.setLineDash([5, 4]);
  ctx.beginPath();
  ctx.moveTo(corners[0][0] * scaleX, corners[0][1] * scaleY);
  for (let i = 1; i < 4; i++) {
    ctx.lineTo(corners[i][0] * scaleX, corners[i][1] * scaleY);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

// ─────────────────────────────────────────────
//  HEX COLOR HELPER
// ─────────────────────────────────────────────

function hexToRgb01(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return { r, g, b };
}

// ─────────────────────────────────────────────
//  DEMO 1 — INTERACTIVE GAUSSIAN HEATMAP
// ─────────────────────────────────────────────

(function initDemo1() {
  const canvas  = document.getElementById('canvas-demo1');
  const cxEl    = document.getElementById('d1-cx');
  const cyEl    = document.getElementById('d1-cy');
  const sxxEl   = document.getElementById('d1-sxx');
  const syyEl   = document.getElementById('d1-syy');
  const anisoEl = document.getElementById('d1-aniso');
  const colorEl = document.getElementById('d1-color');
  const opEl    = document.getElementById('d1-opacity');

  function getParams() {
    const cx    = parseFloat(cxEl.value);
    const cy    = parseFloat(cyEl.value);
    const sxx   = parseFloat(sxxEl.value);
    const syy   = parseFloat(syyEl.value);
    const aniso = parseFloat(anisoEl.value);
    const sxy   = aniso * Math.sqrt(sxx * syy);
    const op    = parseFloat(opEl.value);
    const col   = hexToRgb01(colorEl.value);
    return { cx, cy, sxx, sxy, syy, op, r: col.r, g: col.g, b: col.b };
  }

  function updateLabels(p) {
    document.getElementById('d1-cx-val').textContent    = p.cx.toFixed(2);
    document.getElementById('d1-cy-val').textContent    = p.cy.toFixed(2);
    document.getElementById('d1-sxx-val').textContent   = p.sxx.toFixed(4);
    document.getElementById('d1-syy-val').textContent   = p.syy.toFixed(4);
    document.getElementById('d1-aniso-val').textContent = parseFloat(anisoEl.value).toFixed(2);
    document.getElementById('d1-opacity-val').textContent = p.op.toFixed(2);
  }

  function updateMatrices(p) {
    const inv = invertMatrix2x2(p.sxx, p.sxy, p.sxy, p.syy);
    document.getElementById('m-sxx').textContent = p.sxx.toFixed(5);
    document.getElementById('m-sxy').textContent = p.sxy.toFixed(5);
    document.getElementById('m-syx').textContent = p.sxy.toFixed(5);
    document.getElementById('m-syy').textContent = p.syy.toFixed(5);
    document.getElementById('m-isxx').textContent = inv.ia.toFixed(3);
    document.getElementById('m-isxy').textContent = inv.ib.toFixed(3);
    document.getElementById('m-isyx').textContent = inv.ic.toFixed(3);
    document.getElementById('m-isyy').textContent = inv.id.toFixed(3);
  }

  function redraw() {
    const p = getParams();
    updateLabels(p);
    updateMatrices(p);
    renderHeatmap(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy, p.r, p.g, p.b, p.op);
    drawIsoContours(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy, p.op);
    drawCrosshair(canvas, p.cx, p.cy);
    drawPrincipalAxes(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy);
  }

  [cxEl, cyEl, sxxEl, syyEl, anisoEl, colorEl, opEl].forEach(el => el.addEventListener('input', redraw));
  redraw();
})();

// ─────────────────────────────────────────────
//  DEMO 2 — COVARIANCE GALLERY (STATIC)
// ─────────────────────────────────────────────

(function initGallery() {
  const canvas = document.getElementById('canvas-gallery');
  const dpr = window.devicePixelRatio || 1;
  const cssW = 640;
  const cssH = 220;
  const pw = Math.round(cssW * dpr);
  const ph = Math.round(cssH * dpr);
  canvas.width  = pw;
  canvas.height = ph;
  const ctx = canvas.getContext('2d');

  const N = 5;
  const cellW = pw / N;
  const cellH = ph;
  const s = 0.018;

  const examples = [
    { label: 'Circular',     sxx: s,       sxy: 0,          syy: s,       r: 0.3, g: 0.7, b: 1.0  },
    { label: 'Elongated X',  sxx: s * 3,   sxy: 0,          syy: s * 0.4, r: 1.0, g: 0.6, b: 0.2  },
    { label: 'Elongated Y',  sxx: s * 0.4, sxy: 0,          syy: s * 3,   r: 0.6, g: 1.0, b: 0.4  },
    { label: 'Tilted +45',   sxx: s,       sxy: s * 0.8,    syy: s,       r: 1.0, g: 0.3, b: 0.8  },
    { label: 'Tilted -45',   sxx: s,       sxy: -s * 0.8,   syy: s,       r: 1.0, g: 0.9, b: 0.2  },
  ];

  for (let i = 0; i < N; i++) {
    const ex = examples[i];
    const offX = i * cellW;
    const offY = 0;
    const cellPW = Math.round(cellW);
    const cellPH = Math.round(cellH);

    // Render this Gaussian into a temp canvas
    const tmp = document.createElement('canvas');
    tmp.width  = cellPW;
    tmp.height = cellPH;
    const tmpCtx = tmp.getContext('2d');
    const imgData = tmpCtx.createImageData(cellPW, cellPH);
    const data = imgData.data;

    const cx = 0.5;
    const cy = 0.5;

    for (let py = 0; py < cellPH; py++) {
      for (let px2 = 0; px2 < cellPW; px2++) {
        const ux = px2 / (cellPW - 1);
        const uy = py  / (cellPH - 1);
        const w = evalGaussian(ux, uy, cx, cy, ex.sxx, ex.sxy, ex.syy, 0.95);
        const idx = (py * cellPW + px2) * 4;
        data[idx + 0] = Math.round(ex.r * w * 255);
        data[idx + 1] = Math.round(ex.g * w * 255);
        data[idx + 2] = Math.round(ex.b * w * 255);
        data[idx + 3] = 255;
      }
    }
    tmpCtx.putImageData(imgData, 0, 0);
    ctx.drawImage(tmp, offX, offY);

    // Divider line between cells
    if (i > 0) {
      ctx.save();
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(offX, 0);
      ctx.lineTo(offX, cellH);
      ctx.stroke();
      ctx.restore();
    }
  }
})();

// ─────────────────────────────────────────────
//  DEMO 3 — GAUSSIAN + OBB OVERLAY
// ─────────────────────────────────────────────

(function initDemo3() {
  const canvas  = document.getElementById('canvas-demo3');
  const cxEl    = document.getElementById('d3-cx');
  const cyEl    = document.getElementById('d3-cy');
  const sxxEl   = document.getElementById('d3-sxx');
  const syyEl   = document.getElementById('d3-syy');
  const anisoEl = document.getElementById('d3-aniso');
  const colorEl = document.getElementById('d3-color');
  const opEl    = document.getElementById('d3-opacity');
  const eigenEl = document.getElementById('d3-eigentext');

  function getParams() {
    const cx    = parseFloat(cxEl.value);
    const cy    = parseFloat(cyEl.value);
    const sxx   = parseFloat(sxxEl.value);
    const syy   = parseFloat(syyEl.value);
    const aniso = parseFloat(anisoEl.value);
    const sxy   = aniso * Math.sqrt(sxx * syy);
    const op    = parseFloat(opEl.value);
    const col   = hexToRgb01(colorEl.value);
    return { cx, cy, sxx, sxy, syy, op, r: col.r, g: col.g, b: col.b, aniso };
  }

  function updateLabels(p) {
    document.getElementById('d3-cx-val').textContent    = p.cx.toFixed(2);
    document.getElementById('d3-cy-val').textContent    = p.cy.toFixed(2);
    document.getElementById('d3-sxx-val').textContent   = p.sxx.toFixed(4);
    document.getElementById('d3-syy-val').textContent   = p.syy.toFixed(4);
    document.getElementById('d3-aniso-val').textContent = p.aniso.toFixed(2);
    document.getElementById('d3-opacity-val').textContent = p.op.toFixed(2);
  }

  function updateEigenText(p) {
    const { lambda1, lambda2, v1x, v1y, v2x, v2y } = eigendecompose(p.sxx, p.sxy, p.sxy, p.syy);
    const isDiag = Math.abs(p.sxy) < 1e-6;
    const path = isDiag ? 'diagonal shortcut' : 'full eigendecomposition';
    eigenEl.innerHTML =
      `\u03bb\u2081 = ${lambda1.toFixed(5)}, \u03bb\u2082 = ${lambda2.toFixed(5)}` +
      ` &nbsp;|&nbsp; ` +
      `v\u2081 = (${v1x.toFixed(3)}, ${v1y.toFixed(3)}), v\u2082 = (${v2x.toFixed(3)}, ${v2y.toFixed(3)})` +
      ` &nbsp;|&nbsp; path: <span class="${isDiag ? 'highlight-amber' : 'highlight-green'}">${path}</span>`;
  }

  function redraw() {
    const p = getParams();
    updateLabels(p);
    updateEigenText(p);
    renderHeatmap(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy, p.r, p.g, p.b, p.op);
    drawIsoContours(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy, p.op);
    drawOBB(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy);
    drawPrincipalAxes(canvas, p.cx, p.cy, p.sxx, p.sxy, p.syy);
    drawCrosshair(canvas, p.cx, p.cy);
  }

  [cxEl, cyEl, sxxEl, syyEl, anisoEl, colorEl, opEl].forEach(el => el.addEventListener('input', redraw));
  redraw();
})();

// ─────────────────────────────────────────────
//  DEMO 4 — BUFFER LOADING VISUALISER
// ─────────────────────────────────────────────

(function initDemo4() {
  // smoothStep: maps any real -> [0,1] via sigmoid-like Hermite
  // We use the logistic function as a smooth, bounded mapping
  // (matching the behaviour described: smooth, zero-grad at endpoints)
  function smoothStepMap(x) {
    // Uses logistic / sigmoid: 1/(1+exp(-x))
    return 1.0 / (1.0 + Math.exp(-x));
  }

  const fields = [
    { name: 'center.x',    buf: 0, mapFn: x => smoothStepMap(x) },
    { name: 'center.y',    buf: 1, mapFn: x => smoothStepMap(x) },
    { name: 'sigma[0][0]', buf: 2, mapFn: x => smoothStepMap(x * 0.1) * 0.05 + 0.005 },
    { name: 'sigma[1][1]', buf: 3, mapFn: x => smoothStepMap(x * 0.1) * 0.05 + 0.005 },
    { name: 'anisotropy',  buf: 4, mapFn: x => (smoothStepMap(x) - 0.5) * 1.65 },
    { name: 'color.r',     buf: 5, mapFn: x => smoothStepMap(x) },
    { name: 'color.g',     buf: 6, mapFn: x => smoothStepMap(x) },
    { name: 'color.b',     buf: 7, mapFn: x => smoothStepMap(x) },
    { name: 'opacity',     buf: 8, mapFn: x => smoothStepMap(x) },
  ];

  // Default raw values chosen to give a visible, non-trivial Gaussian
  const defaults = [0.0, 0.0, 2.0, 1.5, 1.0, 1.5, 0.5, 2.0, 1.5];

  const rawVals = [...defaults];
  const tbody = document.getElementById('buf-tbody');
  const sliders = [];
  const rawSpans = [];
  const normSpans = [];
  const finalSpans = [];

  fields.forEach((f, i) => {
    const tr = document.createElement('tr');
    const tdName = document.createElement('td');
    tdName.textContent = f.name;

    const tdSlider = document.createElement('td');
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = -2;
    slider.max = 2;
    slider.step = 0.05;
    slider.value = rawVals[i];
    tdSlider.appendChild(slider);

    const tdRaw = document.createElement('td');
    const rawSpan = document.createElement('span');
    rawSpan.className = 'buf-raw';
    tdRaw.appendChild(rawSpan);

    const tdNorm = document.createElement('td');
    const normSpan = document.createElement('span');
    normSpan.className = 'buf-norm';
    tdNorm.appendChild(normSpan);

    const tdFinal = document.createElement('td');
    const finalSpan = document.createElement('span');
    finalSpan.className = 'buf-final';
    tdFinal.appendChild(finalSpan);

    tr.append(tdName, tdSlider, tdRaw, tdNorm, tdFinal);
    tbody.appendChild(tr);

    sliders.push(slider);
    rawSpans.push(rawSpan);
    normSpans.push(normSpan);
    finalSpans.push(finalSpan);

    slider.addEventListener('input', () => {
      rawVals[i] = parseFloat(slider.value);
      update();
    });
  });

  function update() {
    const cx    = fields[0].mapFn(rawVals[0]);
    const cy    = fields[1].mapFn(rawVals[1]);
    const sxx   = fields[2].mapFn(rawVals[2]);
    const syy   = fields[3].mapFn(rawVals[3]);
    const aniso = fields[4].mapFn(rawVals[4]);
    const sxy   = aniso * Math.sqrt(sxx * syy);
    const cr    = fields[5].mapFn(rawVals[5]);
    const cg    = fields[6].mapFn(rawVals[6]);
    const cb    = fields[7].mapFn(rawVals[7]);
    const op    = fields[8].mapFn(rawVals[8]);

    // Update table display
    fields.forEach((f, i) => {
      const raw  = rawVals[i];
      const norm = smoothStepMap(raw);  // normalised 0-1 from sigmoid
      const fin  = f.mapFn(raw);
      rawSpans[i].textContent   = raw.toFixed(3);
      normSpans[i].textContent  = norm.toFixed(3);
      finalSpans[i].textContent = fin.toFixed(4);
    });

    // Render preview
    const bufCanvas = document.getElementById('canvas-buf');
    renderHeatmap(bufCanvas, cx, cy, sxx, sxy, syy, cr, cg, cb, op);
    drawCrosshair(bufCanvas, cx, cy, '#fff');
  }

  update();
})();
</script>

</body>
</html>
