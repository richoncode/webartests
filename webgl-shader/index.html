<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WebGL Shader</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #back {
      position: fixed;
      top: 20px; left: 20px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-family: -apple-system, sans-serif;
      font-size: 14px;
      font-weight: 600;
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.1);
      z-index: 10;
    }
    #back:hover { background: rgba(255,255,255,0.1); }
    #label {
      position: fixed;
      bottom: 20px; right: 20px;
      color: rgba(255,255,255,0.3);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-align: right;
      line-height: 1.6;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <a id="back" href="../">← Back</a>
  <canvas id="c"></canvas>
  <div id="label">WebGL · GLSL Fragment Shader<br>Raymarched SDF · Phong Lighting</div>

  <script>
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:40px">WebGL not supported</p>'; }

    const vert = `
      attribute vec2 a_pos;
      void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;

    const frag = `
      precision highp float;

      uniform vec2  u_res;
      uniform float u_time;
      uniform vec2  u_mouse;

      // --- Palette ---
      vec3 palette(float t) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.00, 0.33, 0.67);
        return a + b * cos(6.2832 * (c * t + d));
      }

      // --- SDF: animated blob (sphere + displacement) ---
      float sdf(vec3 p) {
        float r = 1.1;
        float d = length(p) - r;
        // Layered sinusoidal displacement for organic wobble
        d += 0.12 * sin(3.5 * p.x + u_time * 1.1)
                  * sin(3.5 * p.y + u_time * 0.7)
                  * sin(3.5 * p.z + u_time * 0.9);
        d += 0.05 * sin(7.0 * p.x - u_time * 0.5)
                  * sin(7.0 * p.z + u_time * 0.6);
        return d;
      }

      // --- Gradient normal ---
      vec3 calcNormal(vec3 p) {
        vec2 e = vec2(0.001, 0.0);
        return normalize(vec3(
          sdf(p + e.xyy) - sdf(p - e.xyy),
          sdf(p + e.yxy) - sdf(p - e.yxy),
          sdf(p + e.yyx) - sdf(p - e.yyx)
        ));
      }

      // --- Soft shadow ---
      float shadow(vec3 ro, vec3 rd) {
        float s = 1.0, t = 0.1;
        for (int i = 0; i < 24; i++) {
          float d = sdf(ro + rd * t);
          s = min(s, 8.0 * d / t);
          t += clamp(d, 0.02, 0.3);
          if (s < 0.001 || t > 8.0) break;
        }
        return clamp(s, 0.0, 1.0);
      }

      // --- Ambient occlusion (stepped) ---
      float ao(vec3 p, vec3 n) {
        float occ = 0.0, scale = 1.0;
        for (int i = 0; i < 5; i++) {
          float h = 0.01 + 0.15 * float(i) / 4.0;
          occ += (h - sdf(p + n * h)) * scale;
          scale *= 0.75;
        }
        return clamp(1.0 - 2.0 * occ, 0.0, 1.0);
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;

        // Mouse-influenced camera orbit
        vec2 m = (u_mouse / u_res - 0.5) * 2.0;
        float yaw   = u_time * 0.25 + m.x * 1.2;
        float pitch = 0.4 + m.y * 0.5;

        vec3 ro = vec3(
          2.8 * cos(pitch) * sin(yaw),
          2.8 * sin(pitch),
          2.8 * cos(pitch) * cos(yaw)
        );
        vec3 target = vec3(0.0);
        vec3 fwd = normalize(target - ro);
        vec3 rgt = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));
        vec3 up  = cross(fwd, rgt);
        vec3 rd  = normalize(uv.x * rgt + uv.y * up + 1.6 * fwd);

        // --- Raymarch ---
        float t = 0.0;
        bool hit = false;
        for (int i = 0; i < 128; i++) {
          float d = sdf(ro + rd * t);
          if (d < 0.0005) { hit = true; break; }
          if (t > 20.0) break;
          t += d * 0.85;
        }

        // --- Background: gradient + faint glow ---
        vec3 col = mix(vec3(0.02, 0.02, 0.06), vec3(0.08, 0.04, 0.12), uv.y * 0.5 + 0.5);
        float glow = exp(-3.5 * length(uv));
        col += vec3(0.1, 0.05, 0.2) * glow;

        if (hit) {
          vec3 p = ro + rd * t;
          vec3 n = calcNormal(p);

          vec3 light1 = normalize(vec3(2.0, 3.0, 2.0));
          vec3 light2 = normalize(vec3(-2.0, -1.0, -1.0));

          float diff1 = max(dot(n, light1), 0.0);
          float diff2 = max(dot(n, light2), 0.0) * 0.3;
          float spec  = pow(max(dot(reflect(-light1, n), -rd), 0.0), 48.0);
          float fres  = pow(1.0 - max(dot(n, -rd), 0.0), 4.0);
          float sh    = shadow(p + n * 0.002, light1);
          float occ   = ao(p, n);

          // Surface colour from normal + time for shifting hues
          vec3 base = palette(length(p) * 0.4 + u_time * 0.12);
          base = mix(base, palette(n.y * 0.5 + 0.5 + u_time * 0.08), 0.4);

          col  = base * (0.05 + 0.9 * diff1 * sh + 0.2 * diff2) * occ;
          col += vec3(1.0) * spec * sh * 0.9;
          col += vec3(0.3, 0.5, 1.0) * fres * 0.5;
          // Subsurface scatter hint
          col += base * 0.08 * max(-dot(n, light1), 0.0);
        }

        // Vignette
        col *= 1.0 - 0.5 * dot(uv, uv);

        // Gamma
        col = pow(max(col, 0.0), vec3(0.4545));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function compile(type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
      return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, compile(gl.VERTEX_SHADER, vert));
    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, frag));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // Fullscreen quad
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(prog, 'a_pos');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

    const uRes   = gl.getUniformLocation(prog, 'u_res');
    const uTime  = gl.getUniformLocation(prog, 'u_time');
    const uMouse = gl.getUniformLocation(prog, 'u_mouse');

    let mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('touchmove', e => {
      mouse.x = e.touches[0].clientX;
      mouse.y = e.touches[0].clientY;
    }, { passive: true });

    function resize() {
      canvas.width  = window.innerWidth  * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    const t0 = performance.now();
    function frame() {
      const t = (performance.now() - t0) / 1000;
      gl.uniform2f(uRes,   canvas.width, canvas.height);
      gl.uniform1f(uTime,  t);
      gl.uniform2f(uMouse, mouse.x * devicePixelRatio, canvas.height - mouse.y * devicePixelRatio);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(frame);
    }
    frame();
  </script>
</body>
</html>
